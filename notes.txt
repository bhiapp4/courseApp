Spring Boot
-Simplifies application development by providing us with auto configurations
-Embedded tomcat server
-Generate reports - configuration reports, application reports - Actuator component
-the dependency management is simplified for our application
-We can develop micro services

Webservices
what is a web service ? service that is exposed over web for data transfer and client server communication

-types - SOAP(JAXWS) and REST(JAXRS)

REST - Representation state transfer architecture

Architecture consists of two things
1.Client - Initiates communication and sends a request
2.Server - responds to the request

--The requests and responses are build around the transfer of representation of resources

--What is a resource ? 
	A resource can be an object(db record), image, pdf etc.., It is a noun not a verb
--What is representation -> 
	XML, JSON, txt, HTML etc..
	
JSON -> Javascript object notation

Employee e = new Employee();
e.fName;
e.getAdress().getCity();

var e = {fName:'Appi',lName:'B',mName:'R;,company:'Jnit'};
{fName:'Appi',lName:'B',mName:'R;,company:'Jnit',address:{city:'Lewsiville',state:'TX'}}
e.fName
e.lName...
e.address.city

<employee>
	<fName>Appi</fName>
	<lName>B</lName>
	<address>
		<city>Lewsiville</city>
		<state>TX</state>
	</address>
</employee>

1MB
Kb's

Load balancers ->


Load balancer infront of my 4 servers

1 server ->2000  
2 server - 2000
3 server -2000
4 server - 2000

Principles of REST

1. Uniform Interface - 
	Resource identification through URL's, - http://serverHost:portNumber/resourceName(courses,users)
	Resource itself is different from representation(XML,JSON)
	The representation will have enough information to make manipulations on the resource
	
2. Stateless interactions - Communication is stateless in nature and the requests are independent of each other
3. Cacheable -The responses generated by the server can be cached by the client which will reduce the bandwidth to a greater extent
4. Client-Server - Both client and server are isolated from each other, client doesn't know anything about servers datastorage and vice versa
5. Layered System - Client can not tell if system is connected to a end server or intermediate, Scalability, we can have a load balancer distribute the load across multiple servers
6. Code on demand- Lets the client update the logic independently from server side logic(ex- web UI logic may be different than server side implementation)

JAXRS - Java API for RESTful webservices - Specification
- Jersey - pure java Oracle implementation
- Spring Data REST - Spring implementation
- Apache CXF - Apache based implementation
- RESTEasy - Jboss implementation

Spring MVC REST architecture can also be used to build REST APIs but spring mvc is not a jax-rs implementation

GET VS POST
--http://hostName/users?userName=appibh&password=appibh123 - GET, Not secure to send information
--http://hostName/users/appibh - GET
--2 Kilo bytes
--Post for create operations- post sends the data in the request body(doesn't put them in the URL)
POST vs PUT
POST- create operations but we can also use it for update operations
PUT - create operations as well as update operations
Put request should be idempotent in nature
-Delete operations
-PATCH - partial updates
-OPTIONS -> get,put,post,delete operations

Path params and query params

http://localhost:8080/courses/12 -> Path param
http://localhost:8080/courses?courseId=12 -> query param -> sorting,filtering and paging

http://localhost:8080/courses.json
Accept http header -> what data type that u want(content-type=application/json, application/xml,application/text)


Best Practices

-Resource should be a noun not a verb
-- Restful services can be developed using Http
-Map appropriate Http methods to CRUD operations
ex: 
GET /courses - Retrieves a list of courses
GET /courses/12 - Retrieves a specific course
POST /courses - Creates a new course
PUT /courses/12 - Updates course #12
PATCH /courses/12 - Partially updates course #12
DELETE /courses/12 - Deletes course #12 - http://localhost:8080/courses/12 with Httpmethod delete
-Resources should be plural
-Define subresource mappings for related entities ex: /courses/12/topics
-Always document the services
-Always version the services
-Implement filtering,sorting and paging with query parameters(/courses?skillLevel=Beginner,/courses?sortBy=name)
-Created aliases for common url's(/courses/recently_created)
-Update and Create operation should return the resource representation
-Use JSON as much as possible
-Create URL's in such a way for requesting a specific representation use .xml or .json in the URL
-define fields with Camelcase -firstName
-Enable caching for the resources returned(etags(IF-NONE-MATCH some tag generated which can be used to figure out the response is changed from prev req,if not return 304) 
	and lastmodified(LAST-MODIFIED))
-Meaningful Http status codes and Error messages should be returned with the responses

200 OK - Response to a successful GET, PUT, PATCH or DELETE. Can also be used for a POST that doesn't result in a creation.
201 Created - Response to a POST that results in a creation. Should be combined with a Location header pointing to the location of the new resource
204 No Content - Response to a successful request that won't be returning a body (like a DELETE request)
304 Not Modified - Used when HTTP caching headers are in play
400 Bad Request - The request is malformed, such as if the body does not parse
401 Unauthorized - When no or invalid authentication details are provided. Also useful to trigger an auth popup if the API is used from a browser
403 Forbidden - When authentication succeeded but authenticated user doesn't have access to the resource
404 Not Found - When a non-existent resource is requested
405 Method Not Allowed - When an HTTP method is being requested that isn't allowed for the authenticated user
410 Gone - Indicates that the resource at this end point is no longer available. Useful as a blanket response for old API versions
415 Unsupported Media Type - If incorrect content type was provided as part of the request
422 Unprocessable Entity - Used for validation errors
429 Too Many Requests - When a request is rejected due to rate limiting

----Servlet------
takes a request, process it and send a response
LoginServlet ->username, password in the request and sends a response ->good,bad
LogoutServlet
RegisterServlet
CouseServlet
UserServlet

www.gmail.com -> server ip - dns name and dns loop -> HttpRequest-Object(Url,Httpmethod-GET)->HttpResponse(status code, data-response data(html,image,json,xml..))

HttpRquest(Post-username and password - request body to your gmail server(tomcat server))
-create an application that understand the request
-run the application on tomcat server(security, threading, containers..(ServletContainer(servlets)))

--http://gmail.com/login

--mapping between the servlet and the url itself - web.xml(deployment descriptor file)

-Browser ->httprequest ->servlet container ->servlet ->response ->servlet container ->httpresponse ->browser

Spring MVC architecture
--- Web application(UI(JSP's/Velcoty templates/thyme leaf)/REST services in combination with ur controllers)
-M -> domain objects
-V -> JSP's,Html,JS
-C -> Dispatcher servlet -> dispatch requests
---One servlet in spring mvc( which will handle all the requests)


-Browser ->httprequest ->servlet container ->disptacher servlet(Request URL mappings) ->Controllers ->response ->servlet container ->httpresponse ->browser
-Spring creates handler mappings(dispatch servlet looks at handler mappings to figure out which controller needs to be invoked)

controller -> 2 responses (1 response could be the view that needs to be rendered on the browser, data it self(json/xml))
controller -> view -> view resolver knows where your views(JSP file(HTML,JS,Jquery..)) are located

----No views(MVC) - REST API
browser ->dispatcher -> handler mappings ->controller -> dispatcher -> browser(response(REST API TOOLS, UI))
---Angular-JS, React-JS, Backbone-js etc...

---Spring MVC
--XML approach/XML-annotations/Complete annotation/Spring boot
--Servlet API (2.5 and below, > 2.5(3.0 and so on)) ->web.xml file is required
2.5 and later -> web.xml is option(annoation way of implementing it)

-Tomcat v8 to deploy or run our application
-Java 8
-Spring JPA/Hibernate
-Spring MVC / Jersey - REST portion of it
-Jackson - (java objects to json and json to java objects, java -> xml and xml->java)
-Lombok
-Spring boot
-Maven

--Setting up Tomcat
-Adding application to tomcat
-configuration of your application

-- JPA configuration
-- Dispatcher servlet
-- Jackson for json conversion

--Request and Respone flow
-Dispatcher servlet -> controller ->Service -> repository -> database
-database -> repository -> service -> controller -> dispatcher servlet -> user

--service layer -> @service is the annotation(@component,@service)
--controller layer ->@Controller annotation, @RESTController annotation

--@Controller vs @RestController annotation
--JSON/XML -> @Controller ->@ResponseBody
ex: 
	public @ResponseBody List<Course> getAllCourses(){

	}
	
	public @ResponseBody Course create(@RequestBody Course course){
	
	}
	
	public String actionLogin(){
		return "home";
	}
	
RestControllers

	@RequestMapping(method=RequestMethod.GET, value="/courses")
	public List<Course> getAllCourses(){

	}

	@RequestMapping(method=RequestMethod.GET, value="/courses/{courseId}")/courses/10
	public Course getCourse(@PathVariable("courseId") Long courseId){

	}

	@RequestMapping(method=RequestMethod.POST, value="/courses")	
	public Course create(@Valid @RequestBody Course course){
		courseService.createCourse(course);
	}

	@RequestMapping(method=RequestMethod.PUT, value="/courses/{courseId}")	
	public Course update(@PathVariable("courseId") Long courseId, @RequestBody Course course){
	
	}
	
	@RequestMapping(method=RequestMethod.DELETE, value="/courses/{courseId}")	
	public HttpStatus delete(@PathVariable("courseId") Long courseId){
	
	}

Spring MVC annotations
-@Controller
-@RestController
-@RequestBody
-@ResponseBody
-@RequestMapping - url to a method
-@PathVariable
-@RequestParam/Query parameters - key value pairs
-@GetMapping
-@PostMapping
-@PutMapping
-@DeleteMapping
-@Valid -> MethodArgumentNotValidException(error messages)
-@ExceptionHandler ->
-@RestControllerAdvice

ResponseEntity handleCourseNotFoundException(CourseNotFoundException cnf){
	return 
}

@ExceptionHanlder(Exception.class)
ResponseEntity handleAnyException(Exception cnf){
	return 
}

	//@RequestMapping(method=RequestMethod.DELETE, value="/courses?courseId={courseId}")	
@DeleteMapping(path="/courses?courseId={courseId}")
public HttpStatus delete(@RequestParam("courseId") Long courseId){
	
}

REST testing tools
-Browser
-Chrome extensions(POSTMAN)

Signup Page -> User fields -> user creation rest operation(POST), another operation check if username is already exists(GET)
Login Page -> validation REST API(check for credentials)(User) -> Post
Courses Page -> List of all courses (GET), Register for course operation(PUT), List of registered courses(GET-> username or userId)
Course creation page -> Create course(POST), Update Course(PUT), Delete Course(Delete),add topic(put), remove topic(delete)

-User Controller
-Course Controller
-Login Controller

--Running from Maven command line
--Download Tomcat 7/8
--Setup Tomcat_Home and point to to the tomcat path
--add the following to tomcat/conf/tomcat-users.xml
<role rolename="manager-gui"/>
<role rolename="admin-gui"/>
<role rolename="manager-script"/>
<role rolename="manager"/>
<user username="admin" password="11qqsd" roles="admin-gui,admin,manager,manager-gui,manager-script,manager-jmx,manager-status"/>    
--Go to .m2 folder and change the settings.xml servers section, if none exists, create a settings.xml file
 <server>
    <id>MyTomcat</id>
    <username>admin</username>
    <password>11qqsd</password>
  </server>
 --change your maven project pom file to add below to plugins
 				<plugin>
					<groupId>org.apache.tomcat.maven</groupId>
					<artifactId>tomcat7-maven-plugin</artifactId>
					<version>2.1</version>
					<configuration>
						<url>http://localhost:8080/manager/text</url>
					    <server>MyTomcat</server>
					    <path>/courseApp</path>
					</configuration>
				</plugin>
  
--Start tomcat 7 server from command line by navigating to bin folder and then execute ./shutdown.bat or ./shutdown.sh from git bash
--then do 
	mvn tomcat7:deploy 
	mvn tomcat7:redeploy
	mvn tomcat7:undeploy
	mvn tomcat7:deploy-only - if the war is already there then this command should be fine
	
	

-Jackson annotations intro - JAXB ->Java to XML to XML to Java
-Performing validations in REST/ Custom data formats - MethodArgumentNotValidException - define exception handler
-Exception handling and defining Custom Exception handlers
-Http status codes
-Swagger documentation for REST API - http://localhost:8080/courseApp/swagger-ui.html
--
-Enabling etag support in spring and returning 304 for subsequent request if the response is not changed
-CORS -> cross origin resource sharing -> cross domain requests

Migrating from Spring mvc to jersey
-Domain objects, repositories, services stay ASIS
-Controllers, exception handling, handling CORS, Swagger documentation is changed

REST Client -> Java code to talk to ur webservice(Jax-RS(Jersey), Apache HttpClient, Spring REST client, Java way with HttpURLConnection)

Spring transaction management
-- Local transactions(modifying one resource) and global transactions(more than one database)
--- Programmatic transaction management and Declarative transaction management
--- Declarative transaction management
- Transaction Manager -> PlatformTransactionManager -> HibernateTransactionManager, JPATransactionManager, JTATransactionmanager...
- Enable transactions
- Define where we need transactions(@Transactional)

--creditAccount, debitAccount, logTransaction

--Unchecked Exception
--Transaction propogation levels in Spring
--Required ->if there is a transaction already present, the method joins the transaction
m1(Required)->m2(Required)
m1(Required)->m2(Requires_new)

--RequiresNew -> It always starts a brand new transaction

lombok
Spring AOP - Aspect oriented programming
------- before, after,around, after returning, after throwing
--joinpoint - where spring has to apply the advice
--pointcut -> set of one or more join points - define that with a pointcut expression

Logging frameworks
log file
log4j - 1 and 2
logback
---Console,File
--Appenders(Console appender, file appender)
--- xml, .properties, json, yaml



Junit, Mockito and Eclemma(Code Coverage)






